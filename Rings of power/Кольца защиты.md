# Кольца защиты

У каждой запускаемой на компьютере программы есть привилегии, информация о которых расположена в таблице дескрипторов секций (2-битовое значение, соответственно 0, 1, 2 или 3) . Программы, являющиеся частью операционной системы запускаются с уровнем привилегий 0 (наивысшим), пользовательские программы (userspace), запускаются с уровнем привилегий 3.  Уровни привилегий 1 и 2 могут использоваться для исполнения драйверов внешних устройств (однако в современных ОС используются только кольца 0 и 3).

**Привилегии колец:**

**Ring 0:**

- Доступ к железу (port mapped IO, memory mapped IO)
- Служебные регистры (ss, cs, ds, es) - stack/code/data/extra(?) segment selector
- Служенбные иструкции (lgdt, lidt, cli/sti, …)

**Ring 3:**

- Доступ к инструкциям/регистрам общего назначения (полностью самостоятельно можно только пользоваться стеком и что-то считать, за всем остальным придется звать ядро)

    При исполнении кода из какого-либо сегмента, процессор смотрит в таблицу дескрипторов сегментов, и подгружает в младшие 2 бита регистра cs уровень привилегий, с которым должно происходить исполнение (CPL). Верхние 13 бит cs отвечают соответственно за номер десткриптора сегмента в таблице дескрипторов сегментов (GDT). (и ещё один бит служебный, по нему регистр понимает где смотреть дескрипторы, в локальной таблице дескрипторов (LDT), или в глобальной(GDT))

**Сегментация**

При запуске ОС создаются 4 базовых сегмента:

```c
#define USER 3
#define KERNEL 0
#define UBASE 0xffff0000

// SEG(EFLAGS, base, offset, privilege level) - запись сегмента в GDT

void init_seg_desc(void) {
	seg_desc[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, KERNEL) 
	seg_desc[SEG_KDATA] = SEG(STA_W,       0, 0xffffffff, KERNEL)
	seg_desc[SEG_UCODE] = SEG(STA_X|STA_R, UBASE, 0xffffffff - UBASE, USER)
	seg_desc[SEG_UDATA] = SEG(STA_W,       UBASE, 0xffffffff - UBASE, USER)

}

// соответственно, физический адрес памяти вычисляется следующим образом:
//  base + SEG_OFFSET
```

### Обработка прерываний

    При возникновении прерывания (аппаратного или программного), процессору надо повысить свой уровень привилегий, обработать прерывание, а после понизить его обратно. 

Пвсевдокод обработки прерывания:

```c
vector X; ←- наш вектор прерываний
gate = idt[X]; <-- берём gate из таблицы прерываний по этому вектору
selector = gate.selector;
dpl = selector.pl; <-- уровень привилегий на котором должен быть обработан X

if cpl > dpl { // cpl - current privilege level
	switch_stack();
	change_privilege_level();
}

// обработка прерывания
```

П**севдо-реализация переключения стеков процессов:** 

- Сохраняем состояние программы (регистры) в стек
- Кладем в %esp верх другого стека
- С нового стека снимаем состояние программы (регистры) и продолжаем исполняться

### Системный вызов

инструкция int $0x84 - обычное прерывание

%eax ← function

%ebx ← arg1

%ecx ← arg2

%edx ←arg3

```c
void trap(registers_t *r) {
	if(r->int_no == T_SYSCALL) {
		switch(r->eax) {
		
		case SYS_exit:
			if(r->ebx) {
				kprinf("Success\n");
			} else { 
				kprintf("Program finished with exit code %d\n", r->ebx);
			}
			killproc(); // переключение стека без сохранения текущего состояния

		case SYS_greet:
			kprintf("Hello world!\n");
			r->eax = 0;
			break;
		
		default:
			kprinf("Unknown syscall);
			r->eax = -1;
			break;
		}
	}
}
```

### Виртуальная память

Страничная виртуальная память - отображение каждого “блока” памяти определенного размера на физическую память внутри процессора

![Screenshot 2023-02-05 193419.png](%D0%9A%D0%BE%D0%BB%D1%8C%D1%86%D0%B0%20%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D1%8B%20833c199060684c7782c6dbcad46227ec/Screenshot_2023-02-05_193419.png)

- У каждого процесса свое отображение
- Стандартный размер страницы - 4KiB
- Первые 10 бит адреса - индекс page directory
- Вторые 10 бит - индекс в page table
- Оставшиеся 12 бит - смещение внутри страницы памяти
- Процессор может положить отображение в свой кэш(TLB - translation lookaside buffer) →  отображение 20-битного префикса адреса на физический адрес памяти. Сбрасывается после переключения процесса